================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2024-11-09T12:28:33.869423

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
compose.yml
db\__init__.py
db\__pycache__\__init__.cpython-312.pyc
db\__pycache__\conn.cpython-312.pyc
db\__pycache__\repository.cpython-312.pyc
db\__pycache__\schema.cpython-312.pyc
db\conn.py
db\repository.py
db\schema.py
game_logic.py
main.py
quiz_api.py
requirements.txt

================================================================
Repository Files
================================================================

================
File: compose.yml
================
services:
  db:
    image: postgres
    restart: always
    user: postgres
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=fccpd
      - POSTGRES_PASSWORD=admin
    expose:
      - 5432
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:

================
File: game_logic.py
================
from typing import List, Dict
import random
from .quiz_api import QuizAPI

class QuizGame:
    def __init__(self, api_key: str):
        self.quiz_api = QuizAPI(api_key)
        self.current_score = 0
        self.current_question = 0
        self.questions = []
        self.total_questions = 0

    def start_new_game(self, category: str = None, difficulty: str = None, 
                      num_questions: int = 10) -> None:
        """Start a new game by fetching questions"""
        self.questions = self.quiz_api.get_questions(
            category=category,
            difficulty=difficulty,
            limit=num_questions
        )
        self.total_questions = len(self.questions)
        self.current_question = 0
        self.current_score = 0

    def get_current_question(self) -> Dict:
        """Get the current question details"""
        if self.current_question >= self.total_questions:
            return None
        return self.questions[self.current_question]

    def check_answer(self, user_answers: Dict[str, bool]) -> bool:
        """Check if the user's answer is correct"""
        current_q = self.questions[self.current_question]
        correct_answers = current_q['correct_answers']
        
        is_correct = True
        for answer_key, is_selected in user_answers.items():
            correct_key = answer_key.replace('answer_', 'correct_') + '_correct'
            if str(is_selected).lower() != str(correct_answers.get(correct_key, 'false')).lower():
                is_correct = False
                break

        if is_correct:
            self.current_score += 1
        self.current_question += 1
        return is_correct

    def is_game_over(self) -> bool:
        """Check if the game is over"""
        return self.current_question >= self.total_questions

    def get_game_summary(self) -> Dict:
        """Get the game summary"""
        return {
            'total_questions': self.total_questions,
            'correct_answers': self.current_score,
            'score_percentage': (self.current_score / self.total_questions) * 100 if self.total_questions > 0 else 0
        }

================
File: main.py
================
import os
import time
from db.conn import DatabaseConnection
from db.repository import UserRepository, QuestionRepository, GameRepository


def clear_terminal():
    """Clear the terminal screen."""
    os.system('cls' if os.name == 'nt' else 'clear')


def print_menu():
    """Display the main menu."""
    clear_terminal()
    print("=== Quiz Game Management System ===")
    print("\nUser Operations:")
    print("1. Create User")
    print("2. Read User")
    print("3. Update User")
    print("4. Delete User")
    print("\nQuestion Operations:")
    print("5. Create Question")
    print("6. Read Question")
    print("7. Update Question")
    print("8. Delete Question")
    print("\nGame Operations:")
    print("9. Create Game")
    print("10. Read Game")
    print("11. Update Game")
    print("12. Delete Game")
    print("\n13. Exit")
    
def handle_user_operations(choice, user_repo):
    """Handle all user-related operations."""
    clear_terminal()
    if choice == "1":
        username = input("Enter username: ")
        user_repo.create_user(username)
        print("User created successfully!")
    elif choice == "2":
        user_id = input("Enter user ID: ")
        user = user_repo.get_user_by_id(user_id)
        print(user if user else "User not found")
    elif choice == "3":
        user_id = input("Enter user ID: ")
        username = input("Enter new username: ")
        user_repo.update_user(user_id, username)
        print("User updated successfully!")
    elif choice == "4":
        user_id = input("Enter user ID: ")
        user_repo.delete_user(user_id)
        print("User deleted successfully!")
        
def handle_question_operations(choice, question_repo):
    """Handle all question-related operations."""
    clear_terminal()
    if choice == "5":
        question_data = {
            "question": input("Enter question: "),
            "description": input("Enter description: "),
            "answers": input("Enter answers: "),
            "multiple_correct_answers": input("Enter multiple_correct_answers: "),
            "correct_answers": input("Enter correct_answers: "),
            "explanation": input("Enter explanation: "),
            "tip": input("Enter tip: "),
            "tags": input("Enter tags: "),
            "category": input("Enter category: "),
            "difficulty": input("Enter difficulty: ")
        }
        question_repo.create_question(**question_data)
        print("Question created successfully!")
    elif choice == "6":
        question_id = input("Enter question ID: ")
        question = question_repo.get_question_by_id(question_id)
        print(question if question else "Question not found")
    elif choice == "7":
        question_id = input("Enter question ID: ")
        question_data = {
            "question": input("Enter new question: "),
            "description": input("Enter new description: "),
            "answers": input("Enter new answers: "),
            "multiple_correct_answers": input("Enter new multiple_correct_answers: "),
            "correct_answers": input("Enter new correct_answers: "),
            "explanation": input("Enter new explanation: "),
            "tip": input("Enter new tip: "),
            "tags": input("Enter new tags: "),
            "category": input("Enter new category: "),
            "difficulty": input("Enter new difficulty: ")
        }
        question_repo.update_question(question_id, **question_data)
        print("Question updated successfully!")
    elif choice == "8":
        question_id = input("Enter question ID: ")
        question_repo.delete_question(question_id)
        print("Question deleted successfully!")

def handle_game_operations(choice, game_repo):
    """Handle all game-related operations."""
    clear_terminal()
    if choice == "9":
        game_data = {
            "user_id": input("Enter user ID: "),
            "questions": input("Enter questions: "),
            "rounds": input("Enter rounds: "),
            "score": input("Enter score: ")
        }
        game = game_repo.create_game(**game_data)
        print("Game created successfully!" if game else "Failed to create game")
    elif choice == "10":
        game_id = input("Enter game ID: ")
        game = game_repo.get_game_by_id(game_id)
        print(game if game else "Game not found")
    elif choice == "11":
        game_id = input("Enter game ID: ")
        game_data = {
            "user_id": input("Enter user ID: "),
            "rounds": input("Enter rounds: "),
            "score": input("Enter score: ")
        }
        game_repo.update_game(game_id, **game_data)
        print("Game updated successfully!")
    elif choice == "12":
        game_id = input("Enter game ID: ")
        game_repo.delete_game(game_id)
        print("Game deleted successfully!")
    
def main():
    db = DatabaseConnection()
    if not db.connect():
        return
    
    session = db.get_session()
    
    repositories = {
        "user": UserRepository(session),
        "question": QuestionRepository(session),
        "game": GameRepository(session)
    }
    
    # Create a menu for CRUD operations
    
    while True:
        print_menu()
        choice = input("\nEnter your choice: ")

        if choice in ["1", "2", "3", "4"]:
            handle_user_operations(choice, repositories["user"])
        elif choice in ["5", "6", "7", "8"]:
            handle_question_operations(choice, repositories["question"])
        elif choice in ["9", "10", "11", "12"]:
            handle_game_operations(choice, repositories["game"])
        elif choice == "13":
            clear_terminal()
            print("Thank you for using the Quiz Game Management System!")
            break
        else:
            print("Invalid choice!")

        input("Press Enter to continue...")
            
    session.close()

if __name__ == '__main__':
    main()

================
File: quiz_api.py
================
import requests
from typing import List, Dict, Optional
import json

class QuizAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://quizapi.io/api/v1"
        self.headers = {
            "X-Api-Key": self.api_key
        }

    def get_questions(self, category: Optional[str] = None, difficulty: Optional[str] = None, 
                     limit: int = 10, tags: Optional[List[str]] = None) -> List[Dict]:
        """Fetch questions from QuizAPI"""
        endpoint = f"{self.base_url}/questions"
        params = {
            "limit": limit,
            "category": category,
            "difficulty": difficulty,
            "tags": tags
        }
        
        response = requests.get(endpoint, headers=self.headers, params=params)
        if response.status_code == 200:
            return response.json()
        else:
            raise Exception(f"Failed to fetch questions: {response.status_code}")

================
File: db\conn.py
================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError

from .schema import Base

class DatabaseConnection:
    def __init__(self):
        # Database connection URL
        self.DATABASE_URL = (
            "postgresql://postgres:admin@localhost:5432/postgres"
        )
        self.engine = None
        self.Session = None

    def connect(self):
        try:
            # Create engine
            self.engine = create_engine(self.DATABASE_URL, echo=True)
            
            # Create all tables
            Base.metadata.create_all(self.engine)
            
            # Create session factory
            self.Session = sessionmaker(bind=self.engine)
            
            print("Successfully connected to the database!")
            return True
            
        except SQLAlchemyError as e:
            print(f"Error connecting to the database: {str(e)}")
            return False

    def get_session(self):
        if self.Session:
            return self.Session()
        raise Exception("Database not connected. Call connect() first.")

================
File: db\repository.py
================
from .schema import User, Question, Game
from sqlalchemy.exc import SQLAlchemyError
from pydantic.types import List

class UserRepository:
    def __init__(self, session):
        self.session = session

    def create_user(self, username: str):
        try:
            user = User(username=username)
            self.session.add(user)
            self.session.commit()
            return user
        except SQLAlchemyError as e:
            self.session.rollback()
            print(f"Error creating user: {str(e)}")
            return None

    def get_user_by_id(self, user_id):
        return self.session.query(User).filter(User.id == user_id).first()



class QuestionRepository:
    def __init__(self, session):
        self.session = session
        
    def create_question(
        self, 
        id: int, 
        question: str, 
        description: str, 
        answers: List[str|None], 
        multiple_correct_answers: bool, 
        correct_answers: List[bool], 
        explanation: str, 
        tip: str | None, 
        tags: List[str|None], 
        category: str, 
        difficulty: str
    ):
        try:
            question = Question(
                id=id, 
                question=question, 
                description=description, 
                answers=answers, 
                multiple_correct_answers=multiple_correct_answers, 
                correct_answers=correct_answers, 
                explanation=explanation, 
                tip=tip, 
                tags=tags, 
                category=category, 
                difficulty=difficulty
            )
            self.session.add(question)
            self.session.commit()
            return question
        except SQLAlchemyError as e:
            self.session.rollback()
            print(f"Error creating question: {str(e)}")
            return None
    
    def get_question_by_id(self, question_id):
        return self.session.query(Question).filter(Question.id == question_id).first()
    
    def get_questions_by_category(self, category):
        return self.session.query(Question).filter(Question.category == category).all()
    
    def get_questions_by_difficulty(self, difficulty):
        return self.session.query(Question).filter(Question.difficulty == difficulty).all()
    
    def get_questions_by_tag(self, tag):
        return self.session.query(Question).filter(Question.tags.contains(tag)).all()
    
    def get_all_questions(self):
        return self.session.query(Question).all()
    
    
class GameRepository:
    def __init__(self, session):
        self.session = session
        
    def create_game(self, user: User, questions: List[Question], rounds: int, score: int):
        questions = [q.id for q in questions]
        try:
            game = Game(user_id=user.id, questions=questions, rounds=rounds, score=score)
            self.session.add(game)
            self.session.commit()
            return game
        except SQLAlchemyError as e:
            self.session.rollback()
            print(f"Error creating game: {str(e)}")
            return None
    
    def get_game_by_id(self, game_id):
        return self.session.query(Game).filter(Game.id == game_id).first()
    
    def get_all_games(self):
        return self.session.query(Game).all()
    
    def get_games_by_user(self, user_id):
        return self.session.query(Game).filter(Game.user_id == user_id).all()
    
    def get_last_game_by_user(self, user_id):
        return self.session.query(Game).filter(Game.user_id == user_id).order_by(Game.id.desc()).first()
    
    def get_games_ordered_by_rounds(self):
        return self.session.query(Game).order_by(Game.rounds).all()
    
    def get_games_ordered_by_score(self):
        return self.session.query(Game).order_by(Game.score).all()

================
File: db\schema.py
================
from sqlalchemy import Column, Integer, String, Boolean
from sqlalchemy import ARRAY
from sqlalchemy.ext.declarative import declarative_base


Base = declarative_base()


class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(50), unique=True, nullable=False)
    
    def __repr__(self):
        return f"User(id={self.id}, username={self.username})"
    
class Question(Base):
    __tablename__ = "questions"
    
    id = Column(Integer, primary_key=True)
    question = Column(String(100), nullable=False)
    description = Column(String(100), nullable=False)
    answers = Column(ARRAY(String(100)))
    multiple_correct_answers = Column(Boolean, nullable=False)
    correct_answers = Column(ARRAY(Boolean))
    explanation = Column(String(100), nullable=False)
    tip = Column(String(100), nullable=True)
    tags = Column(ARRAY(String(100)))
    category = Column(String(100), nullable=False)
    difficulty = Column(String(100))
    
    
class Game(Base):
    __tablename__ = 'games'
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, nullable=False)
    rounds = Column(Integer, nullable=False)
    score = Column(Integer, nullable=False)
    questions = Column(ARRAY(Integer))
    
    
# [
#   {
#     "id": 1,
#     "question": "How to delete a directory in Linux?",
#     "description": "delete folder",
#     "answers": {
#       "answer_a": "ls",
#       "answer_b": "delete",
#       "answer_c": "remove",
#       "answer_d": "rmdir",
#       "answer_e": null,
#       "answer_f": null
#     },
#     "multiple_correct_answers": "false",
#     "correct_answers": {
#       "answer_a_correct": "false",
#       "answer_b_correct": "false",
#       "answer_c_correct": "false",
#       "answer_d_correct": "true",
#       "answer_e_correct": "false",
#       "answer_f_correct": "false"
#     },
#     "explanation": "rmdir deletes an empty directory",
#     "tip": null,
#     "tags": [],
#     "category": "linux",
#     "difficulty": "Easy"
#   }
# ]
